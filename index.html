<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bible Timeline Order</title>
  <style>
    :root { --pad: 16px; --radius: 16px; }
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; margin: 0; background:#f6f7fb; color:#111; }
    header { padding: 18px var(--pad); background: white; border-bottom: 1px solid #e7e7ee; position: sticky; top: 0; z-index: 5; }
    h1 { font-size: 18px; margin: 0 0 6px; }
    p { margin: 0; font-size: 14px; color:#444; line-height: 1.35; }

    main { padding: var(--pad); max-width: 720px; margin: 0 auto; }

    .panel {
      background: white;
      border: 1px solid #e7e7ee;
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
    }

    .hint { font-size: 13px; color:#555; margin: 8px 0 14px; }

    .list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 8px;
      border: 2px dashed #cfd2e3;
      background: #fafbff;
      border-radius: 14px;
    }
    .list.active { border-color:#7c83ff; background:#f1f2ff; }

    .item {
      background: #fff;
      border: 1px solid #d9d9e5;
      border-radius: 14px;
      padding: 14px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      user-select: none;
      touch-action: none;
    }

    /* Big drag handle for thumbs */
    .handle {
      width: 38px;
      height: 38px;
      border-radius: 14px;
      border: 1px solid #d9d9e5;
      display: grid;
      place-items: center;
      font-weight: 800;
      color:#555;
      flex: 0 0 auto;
    }

    .label { font-size: 16px; line-height: 1.2; }

    .item.dragging { opacity: 0.6; }

    .controls { display:flex; gap:10px; flex-wrap: wrap; margin-top: 14px; }
    button {
      border: 1px solid #d9d9e5;
      background: white;
      border-radius: 14px;
      padding: 12px 14px;
      font-weight: 700;
      font-size: 14px;
    }
    button.primary { border-color:#7c83ff; }
    button:active { transform: translateY(1px); }

    .status {
      margin-top: 12px;
      font-size: 14px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid #e7e7ee;
      background: #fff;
    }
    .status.ok { border-color: #b7e3c6; background:#f3fff7; }
    .status.no { border-color: #ffd1d1; background:#fff5f5; }

    .small { font-size: 12px; color:#666; margin-top: 10px; }
  </style>
</head>
<body>
  <header>
    <h1>Bible Timeline Mini-Game</h1>
    <p>Drag the events up/down until they’re in the correct order, then tap <b>Check</b>.</p>
  </header>

  <main>
    <section class="panel">
      <div class="hint">Tip: Grab the <b>≡</b> handle to drag. (Much easier on phones.)</div>

      <div id="timeline" class="list" aria-label="Timeline reorder list"></div>

      <div class="controls">
        <button class="primary" id="checkBtn">Check</button>
        <button id="resetBtn">Reset</button>
        <button id="showBtn">Show Answer</button>
      </div>

      <div id="status" class="status" style="display:none;"></div>
      <div class="small">No score — just a quick timeline puzzle for class.</div>
    </section>
  </main>

  <script>
    const CORRECT = [
      "Before the Flood",
      "The Flood",
      "Scattering of the People",
      "Patriarchs",
      "Exodus",
      "Wandering in the Wilderness",
      "Invasion and Conquest",
      "Judges",
      "United Kingdom",
      "Divided Kingdom",
      "Judah Alone",
      "Captivity",
      "Return",
      "Years of Silence",
      "Life of Christ",
      "Early Church",
      "Letters to Christians"
    ];

    const timeline = document.getElementById("timeline");
    const statusEl = document.getElementById("status");

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function makeItem(text) {
      const el = document.createElement("div");
      el.className = "item";
      el.draggable = true;
      el.dataset.value = text;

      const handle = document.createElement("div");
      handle.className = "handle";
      handle.textContent = "≡";

      const label = document.createElement("div");
      label.className = "label";
      label.textContent = text;

      el.append(handle, label);

      el.addEventListener("dragstart", (e) => {
        el.classList.add("dragging");
        e.dataTransfer.setData("text/plain", text);
        e.dataTransfer.effectAllowed = "move";
      });

      el.addEventListener("dragend", () => {
        el.classList.remove("dragging");
        timeline.classList.remove("active");
      });

      return el;
    }

    function clearStatus() {
      statusEl.style.display = "none";
      statusEl.classList.remove("ok", "no");
      statusEl.textContent = "";
    }

    function setStatus(ok, message) {
      statusEl.style.display = "block";
      statusEl.classList.toggle("ok", ok);
      statusEl.classList.toggle("no", !ok);
      statusEl.textContent = message;
    }

    function currentOrder() {
      return Array.from(timeline.querySelectorAll(".item")).map(i => i.dataset.value);
    }

    function resetGame() {
      clearStatus();
      timeline.innerHTML = "";
      shuffle(CORRECT).forEach(text => timeline.appendChild(makeItem(text)));
    }

    function getDragAfterElement(container, y) {
      const els = [...container.querySelectorAll(".item:not(.dragging)")];
      return els.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          return { offset, element: child };
        }
        return closest;
      }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
    }

    timeline.addEventListener("dragover", (e) => {
      e.preventDefault();
      timeline.classList.add("active");

      const dragging = document.querySelector(".item.dragging");
      if (!dragging) return;

      const after = getDragAfterElement(timeline, e.clientY);
      if (after == null) timeline.appendChild(dragging);
      else timeline.insertBefore(dragging, after);
    });

    timeline.addEventListener("dragleave", () => timeline.classList.remove("active"));
    timeline.addEventListener("drop", (e) => { e.preventDefault(); timeline.classList.remove("active"); });

    document.getElementById("checkBtn").addEventListener("click", () => {
      clearStatus();
      const attempt = currentOrder();
      const ok = attempt.every((v, i) => v === CORRECT[i]);
      setStatus(ok, ok ? "✅ Correct order!" : "❌ Not quite — move a few around and try again.");
    });

    document.getElementById("resetBtn").addEventListener("click", resetGame);

    document.getElementById("showBtn").addEventListener("click", () => {
      clearStatus();
      timeline.innerHTML = "";
      CORRECT.forEach(text => timeline.appendChild(makeItem(text)));
      setStatus(true, "Answer shown. Tap Reset to scramble again.");
    });

    resetGame();
  </script>
</body>
</html>
